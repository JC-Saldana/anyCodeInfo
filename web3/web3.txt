decentralised doesnt need crypto, but web3 does -> crypto is coins and incentive to provide infrastucture

Decentralised app (Dapp) -> i.e with ethereum you make transactions trough mining to emulate aws servers

Backend: instead of server and database on aws, you write smart contracts to store backend with solidity language (object oriented). 
OpenZeppelin -> templates for smart contracts that comply industry standards
Front end like usual but with different auth (ethers and web3.js libraries to access metamask)

Fungible token -> same coin, same value. NFT -> different value

Offchain storage -> IPFS -> decentralised file share like bitTorrent with db like (orbit DB and ThredDb, similar to mongo)


------------
Easy to start, diff to master
3 dapp components -> smart contract (solidity is oop, remix is web ide to see contracts)
			-> truffle (dev suite to write contracts and test them). Ganache is for local blockchain
			-> frontend and backend (fetch users, moralis to watch changes and many tools)
example of apps: wallet, games, exchange, lending protocol, DEFI, NFT, Web3.0, metaverse
-----------
Defi, NFT, Gaming, Web 3.0, Metaverse
Why blockchain? Decentralization, immutable, trustless, transparency
Developer types: core and dapp. Dapp: Smart contracts(solidity), front(js, React), back(pictures into IPFS, get url, store metadata)
IPFS: InterPlanetaryFileSystem: Distributed network of files. NFT's have a link to IPFS
What to study: Solidity, Javascript
Interesting concepts: EVM, Layer 2 scaling
Solidity gets compiled and runs EVM
Metamask wallet to interact with dapps
Eth dev ecosystem: - solidity / js
			 - js libraries to connect to blockchain (web3 js, ethers js)
			 - frameworks: truffle(suite of tools for blockchain dev, includes Ganache for one click local blockchain, web3), hardhat(ethers), remix(online IDE to create smart contracts)